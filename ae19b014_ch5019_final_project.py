# -*- coding: utf-8 -*-
"""AE19B014_CH5019_FINAL_PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j59on7RcciCWhNl37Qn8RtKaSGZlWe5o
"""

#importing required libraries please make sure nltk is installed.
import nltk
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('wordnet')
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.tokenize import sent_tokenize
from nltk.stem import WordNetLemmatizer
from nltk.corpus import wordnet

# Managing stop words
stop_words = stopwords.words('english')
not_stop_words = ['no', 'not', 'have']
stop_words = [word for word in stop_words if not word in not_stop_words]

def tokenizer_cleaner(sentence):
  punc = ['.', '?', '!', ',', ';', ':', '-', '_', '(', ')', '{', '}', '[', ']', '\'', '"', "'", "'s", "'rd", "'st", "'nd", "'th", "'t"]
  words = [word for word in word_tokenize(sentence) if not word in punc and not word in stop_words] # removal of punctuation marks
  return words

def meaning(para): # pass lemmatized para, returns the meanings of all words in the paragraph
  meanings = []
  for word in para:
    if len(wordnet.synsets(word)):
      meanings += tokenizer_cleaner(wordnet.synsets(word)[0].definition())
  return meanings

def check_ques(ques, para):
  q_words = ["who", "what", "when", "where", "why", "how", "is", "can", "does", "do", "did", "are", "whom"]
  check_list = [word for word in ques if not word in q_words]
  meanings = meaning(para)
  for word in check_list:
    if not word in para and not word in meanings:
      print(word)
      return 1
  return 0

def rel_order(common_words, ques, ans):
  ques_join = ''.join([word for word in ques if word in common_words])
  ans_join = ''.join([word for word in ans if word in common_words])
  return (ques_join == ans_join)

def word_freq(ques, para):
  freq = dict.fromkeys(ques, 0)
  for q_word in ques:
    for p_word in para + meaning(para):
      if p_word == q_word:
        freq[q_word]+=1
  return freq

def ans_picker(ques, para):
  lemma = WordNetLemmatizer() # initializing lemmatizer
  sent = [sentence for sentence in sent_tokenize(para)] # tokenizing the paragraph into sentences and storing in a list
  clean_sent = [[word.lower() for word in tokenizer_cleaner(sentence)] for sentence in sent] # cleaning the sentences by removing all punctuations and stopwords and finally converts to lowercase
  clean_ques = [word.lower() for word in tokenizer_cleaner(ques)] # does the same as above, but with the question.
  lemm_para = [lemma.lemmatize(word).lower() for word in tokenizer_cleaner(para)] # lemmatizing the paragraph word by word (Converting to the base/root word for future comparison)
  lemm_ques = [lemma.lemmatize(word) for word in clean_ques] # does the same as above but with the question
  if check_ques(lemm_ques, lemm_para): # checking if all the non question words in the question exist in the paragraph. If not, we declare the question to be invalid. It is assumed that the questions will be from the pargraph only!
    return "Invalid question. Cannot be answered from the given paragraph."
  freq = word_freq(lemm_ques, lemm_para) # creating frequency map for all the words appearing in the lemmatized and cleaned question
  max_match = 0 # This variable denotes 'maximum number' of words in the question found in a sentence from the paragraph. Initialized to 0.
  for i in range(len(clean_sent)): # looping across the different sentences in the paragraph
    lemm_sent = [lemma.lemmatize(word) for word in clean_sent[i]] # lemmatizing the sentences
    match_words = [word for word in lemm_ques if word in lemm_sent or word in meaning(lemm_sent)] # list of 'matching words' present in both question and the sentence 
    foreign = False # tag used for identifying if matching words are present in the actual paragraph or the 'meaning' paragraph
    for word in match_words:
      if not word in lemm_sent:
        foreign = True
        break
    match_len = len(match_words) 
    match_words_freq = [freq[word] for word in match_words] # list containing the freq of matching words. 
    sent_freq_sum = sum(match_words_freq) # Sum of freq of all matching words. Lower the sum, more are the chances of it having the KEY IMPORTANT SPECIAL words in the paragraph
    word_order = rel_order(match_words, lemm_ques, lemm_sent) # Word order matters while choosing the right answer. 'Jack kills Jeff.' and 'Jeff kills Jack.' have the same words, but they can be distinguished from the word order
    if match_len > max_match and (word_order == True or foreign == True): # If the word order matches the question word order or we have foreign words and we have more matching words than earlier, then we have a better answer. We will update our max matching length and other variables as well. 
      max_match = match_len
      ans = sent[i]
      min_freq_sum = sent_freq_sum
      ans_freq = sorted(match_words_freq)
    elif match_len == max_match and (word_order == True or foreign == True) and match_len > 0: 
      if sent_freq_sum < min_freq_sum: # if the number of matching words in a sentence is the same as max, we need to check if it contains more important (rare) words. If yes, we can claim that it may be a better answer.
        ans = sent[i]
        min_freq_sum = sent_freq_sum
        ans_freq = sorted(match_words_freq)
      elif sent_freq_sum == min_freq_sum: # If the number of matching words and total frequency of all matching words is the same, then we check if this sentence has 'rarer' words than the current answer
        new_match = True
        for i in range(len(match_words_freq)):
          if match_words_freq[i] > ans_freq[i]:
            new_match = False
            break
        if new_match == True:
          ans = sent[i]
          ans_freq = sorted(match_words_freq)
  return ans

# Paragraph 1
print("Here are ten sample questions and the corresponding answers given by the model. Please provide your paragraph and question in the text boxes that follow.")
para = "Jellyfish are not really fish. They have no heart, no brain, no kidney, no lungs or gills, no blood—- none of the organs we think are needed to live. They have a mouth, tentacles and tissues which digest food. Tentacles are body parts which are used by animals to feel, catch a prey or move. Jellyfish live in the sea and are found in all oceans. Some jellyfish live in fresh water. Jellyfish are mostly made up of water and their inside parts are held in place by a thin layer of skin. Jellyfish looks like umbrella. A group of jellyfish is called a ‘bloom’, ‘swarm’ or ‘smack’. Jellyfish kill planktons. Some sea turtles kill jellyfish."
ques1 = "What does jellyfish look like?"
print(ques1)
print(ans_picker(ques1, para))
ques2 = "Group of jellyfish is called?"
print(ques2)
print(ans_picker(ques2, para))
ques3 = "Are jellyfish not fish?"
print(ques3)
print(ans_picker(ques3, para))
ques4 = "What do jellyfish kill?"
print(ques4)
print(ans_picker(ques4, para))
ques5 = "Who kills jellyfish?"
print(ques5)
print(ans_picker(ques5, para))
ques6 = "How do they digest food?"
print(ques6)
print(ans_picker(ques6, para))
ques7 = "Do they have gills?"
print(ques7)
print(ans_picker(ques7, para))
ques8 = "Can jellyfish dance?"
print(ques8)
print(ans_picker(ques8, para))

# Paragraph 2
para2 = "A woodpecker is a small bird with a bunch of red feathers on its head. It has a very strong and sharp s beak. These birds are omnivorous and eat fruits, tree saps and insects. Woodpeckers are colourful and beautiful birds, well-known for pecking the wood of trees with their pointed beaks. And this unique characteristic of these birds does justice to their name: woodpecker. You will often see a wood-pecker making holes on a tree trunk. In order to make holes in tree trunks, it first finds a rotten tree trunk, it then clings to the bark. Next, it hits hard against the wood with its beak for hours. The wood-pecker then finds wood-lice or other insects. These insects are its food. The wood-pecker also digs holes in tree-trunks to make a nest."
q1 = "What do woodpeckers eat?" 
print(q1)
print(ans_picker(q1, para2))
q2 = "How is the woodpecker's beak?"
print(q2)
print(ans_picker(q2, para2))
q3 = "What are woodpeckers well-known for?"
print(q3)
print(ans_picker(q3, para2))
q4 = "What is their color?"
print(ans_picker(q4, para2))

# user input menu
while(1):
  print("Press 1 to enter a new paragraph.")
  print("Press 2 to enter a new question.")
  print("Press 3 to exit.")
  ch = int(input())
  if ch == 1:
    print("Enter your paragraph in the textbox below.")
    user_para = input()
  elif ch == 2:
    print("Enter your question in the textbox below.")
    user_ques = input()
  elif ch == 3:
    print("Thank you.")
    break
  else:
    print("Please enter a valid number.")